# Архитектурная схема приложения

## 1. Общая архитектура: Монолитное веб-приложение

Система управления дефектами реализована как монолитное веб-приложение, объединяющее клиентскую (frontend) и серверную (backend) части в едином проекте. Это обеспечивает упрощенное развертывание и управление, а также облегчает взаимодействие между компонентами.

```mermaid
graph LR
    Browser[Веб-браузер] --> |HTTP/HTTPS| Frontend(Next.js App)
    Frontend --> |HTTP/HTTPS API Calls| Backend(FastAPI App)
    Backend --> |SQLAlchemy ORM| Database(SQLite)

    subgraph Frontend (Next.js)
        F1[React Components] --> F2[SCSS Modules]
        F1 --> F3[API Client]
    end

    subgraph Backend (FastAPI)
        B1[API Endpoints] --> B2[Аутентификация/Авторизация]
        B2 --> B3[CRUD операции]
        B3 --> B4[Бизнес-логика]
        B4 --> B5[Взаимодействие с БД (SQLAlchemy)]
        B5 --> B6[Модели данных (ORM)]
    end

    subgraph Database (SQLite)
        D1[Таблицы: Пользователи, Проекты, Дефекты, Комментарии, Вложения]
    end

    B2 --> B1
    B3 --> B1
    F3 --> B1

    style Browser fill:#f9f,stroke:#333,stroke-width:2px
    style Frontend fill:#ccf,stroke:#333,stroke-width:2px
    style Backend fill:#cfc,stroke:#333,stroke-width:2px
    style Database fill:#ffc,stroke:#333,stroke-width:2px
```

## 2. Компоненты архитектуры

### 2.1 Фронтенд (Frontend) - Next.js с SCSS

*   **Технология:** Next.js (React Framework) для отрисовки пользовательского интерфейса, SCSS для стилизации.
*   **Структура:**
    *   `pages/` или `app/` (с использованием App Router): Содержит страницы приложения (например, вход, регистрация, список проектов, детали дефекта, отчеты).
    *   `components/`: Переиспользуемые компоненты React (кнопки, формы, карточки, таблицы).
    *   `styles/`: SCSS-файлы для глобальных стилей и модулей CSS.
    *   `utils/`: Вспомогательные функции (например, для работы с API, форматирования данных).
    *   `services/`: Клиентские сервисы для взаимодействия с Backend API.
*   **Взаимодействие с бэкендом:** Осуществляется через HTTP-запросы (GET, POST, PUT, DELETE) к API FastAPI.
*   **Аутентификация:** Управление JWT-токенами (хранение, отправка с запросами).
*   **Адаптивность:** Разработка интерфейса с учетом адаптивности для различных устройств (ПК, планшеты).

### 2.2 Бэкенд (Backend) - FastAPI

*   **Технология:** FastAPI (Python) для построения RESTful API.
*   **Структура:**
    *   `main.py`: Основная точка входа приложения, определение маршрутов (endpoints), CORS-настройки, middleware для логирования.
    *   `database.py`: Настройка подключения к базе данных SQLite с использованием SQLAlchemy.
    *   `models.py`: Определение ORM-моделей SQLAlchemy, представляющих таблицы базы данных (User, Project, Defect, Comment, Attachment).
    *   `schemas.py`: Определение Pydantic-схем для валидации данных запросов и сериализации ответов API.
    *   `crud.py`: Функции для выполнения операций Create, Read, Update, Delete (CRUD) с базой данных.
    *   `security.py` (или интегрировано в `main.py`/`crud.py`): Функции для хеширования паролей (bcrypt), создания и верификации JWT-токенов, зависимость для получения текущего пользователя.
    *   `backup_db.py`: Скрипт для резервного копирования базы данных.
*   **Аутентификация/Авторизация:** Реализована на основе JWT-токенов и ролей пользователей. Декораторы FastAPI используются для защиты эндпоинтов и проверки прав доступа.
*   **Обработка ошибок:** Использование `HTTPException` для возврата стандартизированных ошибок API.
*   **Логирование:** Интегрировано в `main.py` для отслеживания запросов и системных событий.

### 2.3 База данных (Database) - SQLite

*   **Технология:** SQLite – легковесная, файловая реляционная база данных.
*   **ORM:** SQLAlchemy используется в качестве Object-Relational Mapper для взаимодействия Python-кода с базой данных.
*   **Схема данных:** Содержит таблицы для:
    *   **Users:** Пользователи системы (ID, имя пользователя, email, хешированный пароль, роль, активность).
    *   **Projects:** Строительные проекты (ID, название, описание, дата создания, ID владельца).
    *   **Defects:** Дефекты (ID, заголовок, описание, приоритет, статус, даты создания/обновления/срока выполнения, ID репортера, ID исполнителя, ID проекта).
    *   **Comments:** Комментарии к дефектам (ID, содержание, дата создания, ID автора, ID дефекта).
    *   **Attachments:** Вложения к дефектам (ID, имя файла, путь к файлу, дата загрузки, ID загрузившего, ID дефекта).

### 2.4 Взаимодействие между компонентами
*   **Клиент-Сервер:** Frontend взаимодействует с Backend через RESTful API. Все запросы, требующие аутентификации, включают JWT-токен в заголовке `Authorization`.
*   **Сервер-База данных:** Backend взаимодействует с SQLite через SQLAlchemy ORM. Все операции с данными (CRUD) выполняются через `crud.py`.

## 3. Поток аутентификации

1.  Пользователь отправляет запрос на `POST /token` с именем пользователя и паролем.
2.  Backend проверяет учетные данные, хеширует пароль и сравнивает с хешированным паролем в БД.
3.  В случае успеха, Backend генерирует JWT-токен, содержащий `sub` (имя пользователя) и `exp` (срок действия), и возвращает его Frontend.
4.  Frontend сохраняет JWT-токен (например, в `localStorage` или `cookies`).
5.  Для каждого последующего запроса к защищенным эндпоинтам Frontend включает этот JWT-токен в заголовок `Authorization: Bearer <token>`.
6.  Backend перехватывает запросы, извлекает токен, верифицирует его (проверяет подпись и срок действия) и извлекает данные пользователя. На основе этих данных и ролей пользователя принимается решение о доступе к ресурсу.

## 4. Меры безопасности

*   **Хеширование паролей:** Использование `bcrypt` для безопасного хранения паролей.
*   **Защита от SQL-инъекций:** Использование SQLAlchemy ORM обеспечивает встроенную защиту от SQL-инъекций.
*   **Защита от XSS и CSRF:** Frontend-часть будет реализована с учетом лучших практик защиты от XSS (например, экранирование пользовательского ввода) и CSRF (например, использование токенов CSRF, если применимо, или stateless JWT).
*   **Логирование:** Подробное логирование запросов и важных событий для мониторинга и аудита.
*   **Резервное копирование:** Отдельный скрипт для ежедневного резервного копирования БД.
*   **Контроль доступа к логам:** Доступ к файлам логов будет контролироваться на уровне операционной системы для предотвращения несанкционированного доступа.
